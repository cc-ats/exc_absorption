#!/usr/bin/env python3

"""
TB_HAM: Tight Binding Hamiltonian Generator and Spectral Analysis Tool

This script, `tb_ham.py`, processes Q-Chem output data stored in JSON files that are 
generated by the `extract.py` script. It extracts geometrical and molecular data, 
including atomic coordinates, interactions, and transition dipole moments. Using these 
extracted features, it constructs **molecular aggregates** in different dimensionalities 
(1D, 2D, 3D) and implements the **Tight Binding (TB) model**.

The TB Hamiltonian is then constructed and solved for **eigenvalues** and **eigenvectors**, 
which are used to compute oscillator strengths and absorption spectra.

---

## FUNCTIONALITY:

1. **Data Extraction**:
    - Reads **Q-Chem output files (JSON)** to extract:
        - **Geometries** (atomic types and positions)
        - **Interaction terms** (Coulomb and dipole-dipole interactions)
        - **Excited states** and **transition dipole moments**
    
2. **System Construction**:
    - Constructs **molecular aggregates** with different configurations:
        - **1D** (Zigzag, Armchair)
        - **2D** (Monolayers)
        - **3D** (Multilayers)
    - Assigns interaction terms based on **distance cutoffs**.

3. **Hamiltonian Construction**:
    - Builds the **TB Hamiltonian** matrix, including:
        - **On-site excitation energies** (diagonal elements)
        - **Coupling terms (J)** for different interactions (off-diagonal elements)
    - Supports multiple interaction models:
        - `"direct"`: Coulomb interactions (`J_coul`)
        - `"dipole"`: Dipole-dipole interactions (`J_dipole`)

4. **Spectral Analysis**:
    - Computes **eigenvalues & eigenvectors**.
    - Calculates **oscillator strengths** using eigenvectors.
    - Generates **absorption spectra** using a **Voigt-profile-based broadening**.
    - **Plots spectral weight vs. wavelength**, with peak identification.

---

## USAGE:

### Command-line execution:

python3 tb_ham.py <molecule_name> <functional> <systems> [OPTIONS]

#@author: Sanghita Sengupta, cc-@Shao Group
"""



import os
import glob
import json
import argparse
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import colors
from mpl_toolkits.mplot3d import Axes3D
from scipy.special import wofz
from scipy.integrate import simpson
import traceback


# helper function definitions using parsed Q-chem data 

def find_json_files(base_folder):
    """
    Searches for and returns a list of all JSON files in the specified directory.

    This function:
    - Constructs a file path pattern (`*.json`) dynamically to ensure compatibility across operating systems.
    - Uses `glob.glob()` to find all matching JSON files in the given folder.
    - If no JSON files are found, it prints a warning message.

    Parameters:
    ----------
    base_folder : str
        Path to the directory where JSON files should be searched.

    Returns:
    -------
    matched_files : list
        A list of JSON file paths found in `base_folder`. Returns an empty list if no JSON files are found.
    """
    pattern = os.path.join(base_folder, "*.json") # construct the file path pattern dynamically across different operating systems.
    matched_files = glob.glob(pattern)

    if len(matched_files) == 0:
        print(f"Warning: No JSON files found in {base_folder}.")
   
    return matched_files


def extract_geometry(data, geometry_key = "geometry1"):
    """
    Extracts atom types and their coordinates from the JSON output for a specified geometry.
    
    This function:
    - Retrieves atomic structures from the `geometries` section of a JSON data file.
    - Extracts atom types and their corresponding position vectors.
    - Converts coordinates into a NumPy array for further computations.
    - Raises an error if no geometry data is found.
    - Ensures the extracted coordinates are correctly shaped as a 2D array.
    
    Parameters:
    ----------
    data : dict
        Dictionary containing molecular geometry data from a JSON file.
    geometry_key : str, optional
        The key corresponding to the specific geometry to be extracted (default: "geometry1").
    
    Returns:
    -------
    atoms : list
        A list of atomic types (e.g., ['C', 'H', 'O', ...]).
    coordinates : numpy.ndarray
        A 2D NumPy array of shape (N, 3), where N is the number of atoms, 
        and each row contains the [x, y, z] coordinates in Angstroms.
    
    Raises:
    ------
    ValueError:
        If no geometries are found in the JSON file.
    AssertionError:
        If the extracted coordinates do not have the correct shape.
    """
    
    # begin creating empty lists for initializiation for atoms and co-ordinates
    atoms = []
    coordinates = []
    
    # get geometries as dictionary from the data
    geometries = data.get('geometries', {})
    
    # error print if no geometry present
    if not geometries:
        raise ValueError ("No geometries found in output JSON files.")
    
    # extract specified geometry from the geometries
    geometry_data = geometries.get(geometry_key, [])
    
    # extract atom_type, co-ordinates from the geometry_data
    for atom_data in geometry_data:
        atom_type = atom_data.get('Atom Type')
        position_vector = atom_data.get('Position Vector (Angstrom)')
        if atom_type and position_vector: # begin appending to initialized list
            atoms.append(atom_type)
            coordinates.append(position_vector)
    coordinates = np.array(coordinates)
    #check dimensionality of coordinates before proceeding
    assert coordinates.ndim == 2, f"Coordinates are not properly shaped: {coordinates.shape}"
    return atoms, coordinates


def extract_molecule_data(center_molecule, json_files: list, r_cutoffs=[8,10], z_cutoff=np.inf):
    """
    Extracts molecular data from JSON files, identifies identical molecules, and classifies neighbors based on cutoff distances.

    This function:
    - Extracts atomic structures and coordinates for a given **center molecule**.
    - Computes the **center of mass (COM)** for each molecule.
    - Compares molecules to identify **duplicates**.
    - Filters molecules based on **z-coordinate cutoffs** to classify layers.
    - Constructs **neighbor lists** for each molecule, categorizing them based on interaction distances (`r_cutoffs`).

    Parameters:
    ----------
    center_molecule : tuple
        A tuple containing (`json_index`, `geometry_index`) representing the reference molecule.
    json_files : list
        List of JSON file paths containing molecular structure data.
    r_cutoffs : list, optional
        List of cutoff distances used to classify neighbor interactions (default: `[8, 10]`).
    z_cutoff : float, optional
        Maximum allowed **vertical (z-axis) separation** for defining layers (default: `np.inf`).

    Returns:
    -------
    molecule_data : dict
        Dictionary containing molecule identifiers, atom types, coordinates, and their neighbors.
    unique_molecules : list
        A list containing unique molecular structures without duplicates.

    Raises:
    ------
    ValueError:
        If no geometries are found in the JSON files.
    """
    def compare_molecules(atoms_a, atoms_b, coordinates_a, coordinates_b):
        """compare molecules to check if they are identical"""
        if ''.join(atoms_a) != ''.join(atoms_b): # check composition of molecules
            return False
        differences = np.abs(coordinates_a-coordinates_b).flatten() # difference in atomic coordinates
        if np.max(differences) > 1e-6:
            return False # not identical
        return True # if identical

    # find the z_of c.o.m 
    with open(json_files[center_molecule[0]], 'r') as file:
        data = json.load(file)
    atoms, coordinates = extract_geometry(data, geometry_key=f'geometry {center_molecule[1]}')
    center_of_mass = calculate_center_of_mass(atoms, coordinates)
    z_center = center_of_mass[2]

    # cache the json data to reduce file io operations
    json_cache = {}
    for json_index, json_file in enumerate(json_files):
        with open(json_file, 'r') as file:
            json_cache[json_index] = json.load(file)

    
    #initialize data storage
    com_done = [] # center-of-mass
    molecule_data = {} # dictionary for molecule
    
    # loop through output JSON files
    for json_index, json_file in enumerate(json_files):
        #with open(json_file, 'r') as file:
        #    data = json.load(file)
        data = json_cache[json_index]

        # Loop through multiple geometries for the current dimer # geometry 1 and geometry 2
        for geometry_index in range(1, 3):
            # extract atoms, co-ordinates for calculation of c.o.m
            try:
                atoms, coordinates = extract_geometry(data, geometry_key=f'geometry {geometry_index}')
                center_of_mass = calculate_center_of_mass(atoms, coordinates)

                # check if we are above or below the z_cutoff; needed to filter out layers
                if abs(z_center-center_of_mass[2]) > z_cutoff:
                    continue

                # check for duplicate molecules
                this_ident = f'{json_index},{geometry_index}'
                if this_ident in molecule_data or f'{center_of_mass}' in com_done:
                    continue
                
                # normalize coordinates by c.o.m
                min_x = np.min(coordinates[:,0])
                min_y = np.min(coordinates[:,1])
                min_z = np.min(coordinates[:,2])
                coordinates -= center_of_mass # shift to bring to origin for visualization purposes

                # compare with existing molecules
                this_molecule = [this_ident, atoms, coordinates]
                for key_ident, [dict_ident, dict_atoms, dict_coordinates, dict_neighbors] in molecule_data.items():
                    # check if these are the same
                    if compare_molecules(atoms, dict_atoms, coordinates, dict_coordinates):
                        this_molecule = [dict_ident, dict_atoms, dict_coordinates]
                        break
                
                # Block for neighbor molecules
                # initialize neighbor level list; stores different neighbor groups, each corresponding to a distance range.
                neighbor_levels = []
                for i in range(0,len(r_cutoffs)):
                    r_min = 0 if i == 0 else r_cutoffs[i-1]
                    r_max = r_cutoffs[i]
                    # initialize neighbor level
                    neighbor_level = []
                    neighbor_com_done = [] 
                    # loop over json files and create neighbor data
                    for neighbor_json_index, neighbor_json_file in enumerate(json_files):
                        #with open(neighbor_json_file, 'r') as file:
                        #    neighbor_data = json.load(file)
                        neighbor_data = json_cache[neighbor_json_index]

                        # loop over two possible geometries but avoids comparing with itself
                        for neighbor_geometry_index in range(1, 3):
                            if neighbor_json_index == json_index and neighbor_geometry_index == geometry_index:
                                continue
                            # extract atoms, co-ordinates to calculate c.o.m of neighbors
                            try:
                                neighbor_atoms, neighbor_coordinates = extract_geometry(neighbor_data, geometry_key=f'geometry {neighbor_geometry_index}')
                                neighbor_center_of_mass = calculate_center_of_mass(neighbor_atoms, neighbor_coordinates)
                                if f'{neighbor_center_of_mass}' in neighbor_com_done: # do not duplicate
                                    continue
                                # compute neighbor distance 
                                distance = np.linalg.norm(neighbor_center_of_mass - center_of_mass)
                                z_distance = abs(neighbor_center_of_mass[2] - center_of_mass[2]) # compute for deciding on layer distance
                                
                                if distance > r_min and distance <= r_max and z_distance <= z_cutoff: # cut-off implementation for filtering
                                    # start storing valid neighbors as molecule identifier, relative center of mass, distance
                                    neighbor_level.append([f'{neighbor_json_index},{neighbor_geometry_index}', neighbor_center_of_mass - center_of_mass, distance])
                                    neighbor_com_done.append(f'{neighbor_center_of_mass}')
                            except Exception as e: # error printing
                                if "No geometries found" not in str(e):
                                    print('inner:', e)
                                    traceback.print_exc()
                                continue

                    # sort neighbor list in ascending order of neigbor distance
                    neighbor_level.sort(key=lambda x: np.linalg.norm(x[1]), reverse=False) # reverse=False--->ascending order
                    # store neighbor data
                    neighbor_levels.append(neighbor_level)
                # appends neighbor level to molecule
                this_molecule.append(neighbor_levels)
                # molecule stored
                molecule_data[this_ident] = this_molecule
                com_done.append(f'{center_of_mass}')
            # error handling
            except Exception as e:
                if "No geometries found" not in str(e):
                    print('outer', e)
                    traceback.print_exc()
                continue
    #print(molecule_data['0,1'][3][3])
    #print(json_files)
    
    #exit()
    # can comment this out. and then don't return
    unique_molecules = {val[0]:val[1:] for key, val in molecule_data.items()}
    unique_molecules = [val for key, val in unique_molecules.items()]
    return molecule_data, unique_molecules


def extract_interaction_terms(json_files: list, combine='14.014,14.013', caldip=True):
    """
    Extracts interaction terms and excited state properties from a list of molecular dimer JSON files.
    
    This function:
    - Loads molecular dimer data from JSON files.
    - Computes center-of-mass (COM) distances between molecules.
    - Extracts excited state properties such as:
        - Excitation energies (`Qx`, `Qy`)
        - Transition dipole moments (`Tx`, `Ty`)
    - Retrieves interaction matrices for:
        - Coulomb interaction (`J_coul`)
        - Dipole-dipole interaction (`J_dipole`)
    - Assigns a unique **color code** to each interaction distance for visualization.
    - Stores extracted data in a dictionary **sorted by interaction distance**.
    - Writes extracted data into a `.dat` file for **post-processing and visualization**.
    
    Parameters:
    ----------
    json_files : list
        List of JSON file paths containing molecular dimer interaction data.
    
    Returns:
    -------
    interaction_terms : dict
        A dictionary where:
        - **Keys**: Interaction distances (formatted as strings).
        - **Values**: A dictionary containing:
            - `Qx1, Qy1, Qx2, Qy2`: Excitation energies of molecules.
            - `Tx1, Ty1, Tx2, Ty2`: Transition dipole moments.
            - `J_coul`: 2×2 Coulomb interaction matrix.
            - `J_dipole`: 2×2 Dipole-dipole interaction matrix.
            - `color`: Assigned color code for visualization.
    
    Raises:
    ------
    Exception:
        If a JSON file is missing required data, prints an error message.
    """
    # initialize variables
    interaction_terms = {} # dictionary that stores interaction data for each distance, key ---> distance, values ---> interaction

    lengths = [] # center-of-mass distances
    colors = ['#9F0162', '#009F81', '#008DF9', '#FF5AAF', '#00FCCF', '#8400CD', '#008DF9', '#00C2F9', '#FFB2FD','#A40122'] 
    colors_index = 0 # assigns colors to different distances
    # loop over JSON files, data loading
    for json_index, json_file in enumerate(json_files):
        with open(json_file, 'r') as file:
            data = json.load(file)
        # extract molecular geometries for the dimers, calculate c.o.m
        try:
            atoms1, coordinates1 = extract_geometry(data, geometry_key=f'geometry 1')
            center_of_mass1 = calculate_center_of_mass(atoms1, coordinates1)
            atoms2, coordinates2 = extract_geometry(data, geometry_key=f'geometry 2')
            center_of_mass2 = calculate_center_of_mass(atoms2, coordinates2)

            # compute molecule relative c.o.m distance 
            distance_vec = center_of_mass1-center_of_mass2
            distance_label = f'{np.linalg.norm(distance_vec):.3f}'

            # Extract excited states
            excited_states = data.get('excited_states', [])
            interactions = data.get('interactions', [])

            if 'interactions' in data and len(data['interactions']) >= 1:
                # Extract Coulomb and dipole-dipole interactions
                Jxx_coul =   interactions[0]["Coulomb Interaction (eV)"]
                Jyx_coul =   interactions[1]["Coulomb Interaction (eV)"]
                Jxy_coul =   interactions[2]["Coulomb Interaction (eV)"]
                Jyy_coul =   interactions[3]["Coulomb Interaction (eV)"]
                Jxx_dipole = interactions[0]["Dipole-Dipole Interaction (eV)"]
                Jyx_dipole = interactions[1]["Dipole-Dipole Interaction (eV)"]
                Jxy_dipole = interactions[2]["Dipole-Dipole Interaction (eV)"]
                Jyy_dipole = interactions[3]["Dipole-Dipole Interaction (eV)"]
                Tx1 = excited_states[0].get("Transition Dipole Moment", None),
                Ty1 = excited_states[1].get("Transition Dipole Moment", None),
                Tx2 = excited_states[2].get("Transition Dipole Moment", None),
                Ty2 = excited_states[3].get("Transition Dipole Moment", None),

                if caldip:
                    def calculate_dipole_dipole_interaction(dipole_1, dipole_2, r_vec):
                        """
                        Compute the dipole-dipole interaction energy between two dipoles.

                        Parameters:
                        dipole_1 (numpy array): Transition dipole moment vector for dipole 1.
                        dipole_2 (numpy array): Transition dipole moment vector for dipole 2.
                        r_vec (numpy array): Vector separating the two dipoles.

                        Returns:
                        float: Dipole-dipole interaction energy in eV.
                        """

                        r = np.linalg.norm(r_vec)  # Compute the magnitude of the distance vector
                        if r == 0:
                            raise ValueError("Distance between dipoles cannot be zero.")

                        # Dipole-dipole interaction formula
                        interaction_energy = ((np.dot(dipole_1, dipole_2) / r**3) -
                                              (3 * np.dot(dipole_1, r_vec) * np.dot(dipole_2, r_vec) / r**5))

                        return interaction_energy * 27.21  # Convert Hartree to eV

                    trans_dip = [Tx1[0], Ty1[0]]
                    dipole_matrix = np.zeros((2, 2))

                    # Compute interaction energies for each combination of dipoles
                    bohr_to_angstrom = 0.529177
                    for i, dip1 in enumerate(trans_dip):
                        for j, dip2 in enumerate(trans_dip):
                            dipole_matrix[i, j] = calculate_dipole_dipole_interaction(dip1, dip2, distance_vec/bohr_to_angstrom)

                    # Match the signs of Jdip loaded to Jdip calculated
                    Jxx_dipcal, Jxy_dipcal = dipole_matrix[0]
                    Jyx_dipcal, Jyy_dipcal = dipole_matrix[1]
                    if np.sign(Jxx_dipcal) != np.sign(Jxx_dipole):
                        Jxx_dipole *= -1.0
                        Jxy_dipole *= -1.0
                        Jyx_dipole *= -1.0
                        Jyy_dipole *= -1.0
                    if np.sign(Jxx_dipcal) != np.sign(Jxx_coul):
                        Jxx_coul *= -1.0
                        Jxy_coul *= -1.0
                        Jyx_coul *= -1.0
                        Jyy_coul *= -1.0
                    print(f'dipcal: {Jxx_dipcal:.4f}, {Jxy_dipcal:.4f}, {Jyx_dipcal:.4f}, {Jyy_dipcal:.4f}')
                    print(f'dipole: {Jxx_dipole:.4f}, {Jxy_dipole:.4f}, {Jyx_dipole:.4f}, {Jyy_dipole:.4f}')
                    print(f'  coul: {Jxx_coul:.4f}, {Jxy_coul:.4f}, {Jyx_coul:.4f}, {Jyy_coul:.4f}')
                    print()
                
                # excitation energy, transition dipole moments, storing J as 2 X 2 matrix
                results = {
                    "Qx1": excited_states[0].get("Excitation Energy (eV)", None),
                    "Qy1": excited_states[1].get("Excitation Energy (eV)", None),
                    "Qx2": excited_states[2].get("Excitation Energy (eV)", None),
                    "Qy2": excited_states[3].get("Excitation Energy (eV)", None),
                    "Tx1": excited_states[0].get("Transition Dipole Moment", None),
                    "Ty1": excited_states[1].get("Transition Dipole Moment", None),
                    "Tx2": excited_states[2].get("Transition Dipole Moment", None),
                    "Ty2": excited_states[3].get("Transition Dipole Moment", None),
                    "J_coul": np.array([
                        [Jxx_coul, Jyx_coul],
                        [Jxy_coul, Jyy_coul],
                    ]),
                    "J_dipole": np.array([
                        [Jxx_dipole, Jyx_dipole],
                        [Jxy_dipole, Jyy_dipole],
                    ])
                }
                #print(length, results)
                if distance_label in interaction_terms:
                    interaction_terms[distance_label].append([distance_vec, results])
                else:
                    interaction_terms[distance_label] = [[distance_vec, results]]
            else:
                print(f'{json_file} has no defined interactions!')
        # error handling
        except Exception as e:
            if "No geometries found" not in str(e):
                print(e)
                traceback.print_exc()
            continue

    # assign color to interactions based on distances
    unique_terms = sorted(interaction_terms.values(), key=lambda x: np.linalg.norm(x[0][0]))
    for unique_term in unique_terms:
        key = f'{np.linalg.norm(unique_term[0][0]):.3f}'
        for interaction_term in interaction_terms[key]:
            interaction_term[1]['color'] = colors[colors_index]
        colors_index += 1
        #colors_index = ['b','r','g']
        if colors_index >= len(colors):
           colors_index = 0

    # Deal with special cases by adding them each to respective
    # list of interaction lengths and vectors
    if len(combine) > 0:
        key1, key2 = combine.split(',')
        interaction_terms[key1].append(interaction_terms[key2][0])
        interaction_terms[key2].append(interaction_terms[key1][0])
           
    # Print and save data and write into a .dat file for later processing (visualization, etc.)
    r_min = [0] 
    r_max = [51]
    with open (f'{functional}_table.dat', 'w') as output_file:
        header = f'{"length":>10}  {"Qx1":>10} {"Qy1":>10} {"Tx1_x":>10} {"Tx1_y":>10} {"Tx1_z":>10} {"Ty1_x":>10} {"Ty1_y":>10} {"Ty1_z":>10} {"J_coul_xx":>10} {"J_coul_xy":>10} {"J_coul_yx":>10} {"J_coul_yy":>10} {"J_dipole_xx":>12} {"J_dipole_xy":>12} {"J_dipole_yx":>12} {"J_dipole_yy":>12}'
        print(header)
        output_file.write(header+'\n')
        for index, unique_term in enumerate(unique_terms):
            for [distance_vec, results] in unique_term:
                contents = f'{np.linalg.norm(distance_vec):+10.4e}  {results["Qx1"]:+10.2e} {results["Qy1"]:+10.2e} {results["Tx1"][0]:+10.2e} {results["Tx1"][1]:+10.2e} {results["Tx1"][2]:+10.2e} {results["Ty1"][0]:+10.2e} {results["Ty1"][1]:+10.2e} {results["Ty1"][2]:+10.2e} {results["J_coul"][0][0]:+10.2e} {results["J_coul"][0][1]:+10.2e} {results["J_coul"][1][0]:+10.2e} {results["J_coul"][1][1]:+10.2e} {results["J_dipole"][0][0]:+12.2e} {results["J_dipole"][0][1]:+12.2e} {results["J_dipole"][1][0]:+12.2e} {results["J_dipole"][1][1]:+12.2e}'
                if len(unique_term) > 1:
                    print('\033[1m'+contents+'\033[0m')
                else:
                    print(contents)
                output_file.write(contents+'\n')
    return interaction_terms




# helper function definitions for center-of-mass, building system and Hamiltonian construction


def calculate_center_of_mass(atoms, coordinates):
    """
    Computes the center of mass (COM) of a molecule given atomic types and coordinates.
    
    This function:
    - Retrieves atomic weights for common elements (H, C, N, O).
    - Constructs an array of atomic masses based on the given atomic species.
    - Ensures input arrays have the correct dimensions.
    - Computes the center of mass using the mass-weighted sum formula.
    
    Parameters:
    ----------
    atoms : list
        A list of atomic symbols representing the molecule's atoms (e.g., ['C', 'H', 'O']).
    coordinates : numpy.ndarray
        A 2D NumPy array of shape `(N, 3)`, where N is the number of atoms, 
        and each row contains the [x, y, z] coordinates of an atom.
    
    Returns:
    -------
    center_of_mass : numpy.ndarray
        A NumPy array of shape `(3,)`, representing the [x, y, z] coordinates of the molecule's center of mass.
    
    Raises:
    ------
    AssertionError:
        - If `masses` is not a 1D array.
        - If `coordinates` is not a 2D array.
        - If the number of atoms and mass entries do not match.
    """
    # Define atomic weights for common elements
    atomic_weights = {
        'H': 1.008, 'C': 12.011, 'N': 14.007, 'O': 15.999
    }

    masses = np.array([atomic_weights[atom] for atom in atoms])
   
    assert masses.ndim == 1, "Masses should be a 1D array."
    assert coordinates.ndim == 2, "Coordinates should be a 2D array."
    assert coordinates.shape[0] == masses.shape[0], "Number of atoms and mass entries must match."
   
    center_of_mass = np.einsum('i,ij->j', masses, coordinates) / masses.sum()
   
    return center_of_mass


def build_system(cols, rows, molecule_data, layers=1, zigzag=0):
    """
    Builds a molecular system in 1D, 2D, or 3D by arranging molecules according to extracted molecular data.
    
    The function:
    - Initializes molecular coordinates based on a reference dimer structure.
    - Constructs 1D (zigzag), 2D (armchair), and 3D layered molecular structures.
    - Assigns molecule types and positions based on the provided neighbor information.
    - Ensures correct placement using relative displacement vectors (`a_to_b_left`, `a_to_b_right`, etc.).
    
    Parameters:
    ----------
    cols : int
        Number of columns in the system (for 2D or 3D structures).
    rows : int
        Number of rows in the system.
    molecule_data : dict
        Dictionary containing molecular data (atoms, coordinates, and neighbor information).
    layers : int, optional
        Number of layers in the system (default: 1, meaning a single-layered structure).
    zigzag : int, optional
        - 0: Builds a regular armchair or 2D/3D system.
        - 1: Constructs a 1D zigzag structure using `molecule A` as the reference.
        - 2: Constructs a 1D zigzag structure using `molecule B` as the reference.
    
    Returns:
    -------
    mol_coordinates : numpy array
        Array containing the coordinates of the molecular system.
    mol_identifiers : list
        List of molecule identifiers ('1' or '2'), specifying the molecule type at each coordinate.
    atm_coordinates : numpy array
        Array of atomic coordinates within each molecule.
    atm_identifiers : list
        List of atom types corresponding to `atm_coordinates`.
    mol_layer : list
        List indicating which layer each molecule belongs to (for multilayer systems).
   """
    
    # initialize the systems: molecular data and then neighbors
    a_atoms, a_coords, a_neighbors = molecule_data[f'0,1'][1:] # '0,1' is the molecule identifier, first molecule
    b_atoms, b_coords = molecule_data[a_neighbors[0][0][0]][1:-1] # second molecule, using neighbor levels; check prints to understand data structure

    # a to b distances in plane: 
    a_to_b_left = a_neighbors[1][0][1]
    a_to_b_right = a_neighbors[1][1][1]
    a_to_b_down = a_neighbors[0][0][1]

    # a to b interlayer distance
    a_to_b_below = np.array([0.0,0.0,0.0])
    if layers > 1 and len(a_neighbors) >= 4:
        # neighbor in another layer
        a_to_b_below = a_neighbors[3][0][1] # this belongs to another layer

        # here we search for a distance of 16.90 roughly, to make sure we get the right one
        for neighbor in a_neighbors[3][1:]:
            if np.linalg.norm(neighbor[1]) < 16.91 and np.linalg.norm(neighbor[1]) > 16.89:
                a_to_b_below = neighbor[1]
        assert np.linalg.norm(a_to_b_below) > 14.3, f"Distance between layers would be {np.linalg.norm(a_to_b_below):.3f}, likely incorrect"
    elif layers > 1:
        assert len(a_neighbors) >= 4, f"Layers greater than 1 requires r cutoff of --rcut 8 10 15 17"
   
    # intialize data storage: building a single column first (grid horizontal)
    mol_coordinates = []
    atm_coordinates = []
    mol_identifiers = []
    atm_identifiers = []
    mol_layer = []

    # 1D system: zigzag in one direction, begining at molecule a as reference
    if zigzag==1:
        initial = np.array([0.0,0.0,0.0]) + a_to_b_below # needs a reference vector to begin

        mol_coordinates.append(initial+(a_to_b_right-a_to_b_left))
        atm_coordinates.append(initial+a_coords+(a_to_b_right-a_to_b_left))
        mol_identifiers.append('1')
        atm_identifiers.append(a_atoms)
        mol_layer.append(0)
        # depending on even parity or odd, zigzag pattern is selected: left---->down
        for row in range(rows-1): # process all rows except first one
            # Start at the position of the last coordinate
            if (row % 2) == 0: # even parity move left, place molecule b
                mol_coordinates.append(mol_coordinates[-1]-a_to_b_left)# with respect to last added molecules position; each molecule placed relative to last one
                atm_coordinates.append(b_coords + mol_coordinates[-1])
                mol_identifiers.append('2')
                atm_identifiers.append(b_atoms)
            else: # odd parity move down, place molecule a
                mol_coordinates.append(mol_coordinates[-1]+a_to_b_down)
                atm_coordinates.append(a_coords + mol_coordinates[-1])
                mol_identifiers.append('1')
                atm_identifiers.append(a_atoms)
            mol_layer.append(0) # store layer information
            distance = f'{np.linalg.norm(mol_coordinates[-1]-mol_coordinates[-2]):.3f}' # print distance to check dimers used in zigzag pattern
           
            #print("zigzag==1", np.linalg.norm(a_to_b_left), np.linalg.norm(a_to_b_right))
            #exit()
    elif zigzag==2: # the other zigzag direction, reference is b molecule
        initial = np.array([0.0,0.0,0.0]) + a_to_b_below # needs a reference vector to begin

        mol_coordinates.append(initial)
        atm_coordinates.append(initial+b_coords)
        mol_identifiers.append('2')
        atm_identifiers.append(b_atoms)
        mol_layer.append(0) 
        # once again with even or odd parity, zigzag pattern is chosen
        for row in range(rows-1): # process all rows except first
            # Start at the position of the last coordinate
            if (row % 2) == 0: # even parity move down, place molecule a
                mol_coordinates.append(mol_coordinates[-1]+a_to_b_down)
                atm_coordinates.append(a_coords + mol_coordinates[-1])
                mol_identifiers.append('1')
                atm_identifiers.append(a_atoms)
            else: # odd parity move right, place molecule b
                mol_coordinates.append(mol_coordinates[-1]-a_to_b_right)
                atm_coordinates.append(b_coords + mol_coordinates[-1])
                mol_identifiers.append('2')
                atm_identifiers.append(b_atoms)
            mol_layer.append(0)
            distance = f'{np.linalg.norm(mol_coordinates[-1]-mol_coordinates[-2]):.3f}' # print distance to check dimers used in zig zag patter
            
            #print("zigzag==2", np.linalg.norm(a_to_b_down), np.linalg.norm(a_to_b_right))
            #exit()

    # build 2D, 3D or regular 1d systems (armchair, first zigzag:BC)
    if zigzag==0:
        for layer in range(layers):
            #print(layer, a_to_b_below, layer*a_to_b_below)
            initial = np.array([0.0,0.0,0.0]) + layer*a_to_b_below #first coordinate for the layer in case of 3D
            for col in range(cols): # loop over columns: horizontal grid
                mol_coordinates.append(initial+col*(a_to_b_right-a_to_b_left))
                atm_coordinates.append(initial+a_coords+col*(a_to_b_right-a_to_b_left)) # place a molecule
                mol_identifiers.append('1')
                atm_identifiers.append(a_atoms)
                mol_layer.append(layer)
                if len(mol_coordinates) >= 2: # distance between adjacent molecules, atleast 2 molecules exist
                    distance = np.linalg.norm(mol_coordinates[-1]-mol_coordinates[-2])
                # expand to 2D structure by adding rows, pattern repeat after every 4 row    
                for row in range(rows-1): 
                    # Start at the position of the last coordinate, begin forming armchair
                    if (row % 4) == 0: # row 0, move left
                        mol_coordinates.append(mol_coordinates[-1]-a_to_b_left)
                    if (row % 4) == 1: # row 1, move down
                        mol_coordinates.append(mol_coordinates[-1]+a_to_b_down)
                    if (row % 4) == 2: # row 2, move right
                        mol_coordinates.append(mol_coordinates[-1]-a_to_b_right)
                    if (row % 4) == 3: # row 3, move down
                        mol_coordinates.append(mol_coordinates[-1]+a_to_b_down)
                   
                    # There are two molecules, so we alternate atom type since every dimer file has two molecules
                    if row % 2 == 0: # place molecule b when even parity
                        atm_coordinates.append(b_coords + mol_coordinates[-1])
                        mol_identifiers.append('2')
                        atm_identifiers.append(b_atoms)
                        mol_layer.append(layer)
                    else: # place molecule a with odd parity
                        atm_coordinates.append(a_coords + mol_coordinates[-1])
                        mol_identifiers.append('1')
                        atm_identifiers.append(a_atoms)
                    mol_layer.append(layer)
                    distance = np.linalg.norm(mol_coordinates[-1]-mol_coordinates[-2])
                    
       

    # move the entire system about the origin, which will clean up the plot nicely
    mol_coordinates = np.array(mol_coordinates)
    atm_coordinates = np.array(atm_coordinates)
    mol_center = np.average(mol_coordinates, axis=0)
    mol_coordinates -= mol_center
    for i in range(len(atm_coordinates)):
        atm_coordinates[i] -= mol_center
    return mol_coordinates, mol_identifiers, atm_coordinates, atm_identifiers, mol_layer


def build_matrix(coordinates, identifiers, interaction_terms, r_cutoffs=[8, 10], z_cutoff=np.inf, coupling='J_dipole'):
    """
       Builds the Hamiltonian matrix for a system of N molecules, resulting in a 2N × 2N square matrix.
       
       The matrix contains:
       - Diagonal elements representing excitation energies (Qx, Qy) for each molecule.
       - Off-diagonal elements representing interaction strengths (J_dipole, J_coul, etc.).
       
       Interactions are determined based on:
       - Pairwise distances between molecules.
       - Cutoff distances (`r_cutoffs`) that define interaction ranges.
       - A `z_cutoff` that limits vertical interactions.

       Parameters:
       ----------
       coordinates : list of numpy arrays
           List of N molecular center-of-mass coordinates (each as a 3D numpy array).
       identifiers : list of str
           List of molecule type identifiers ('1', '2', etc.) for retrieving interaction terms.
       interaction_terms : dict
           Dictionary mapping distance values to interaction terms (excitation energies and couplings).
       r_cutoffs : list, optional
           List of cutoff distances that define interaction ranges (default: [8, 10]).
       z_cutoff : float, optional
           Maximum allowed vertical separation for interaction (default: np.inf).
       coupling : str, optional
           Specifies which interaction term to use (default: 'J_dipole').

       Returns:
       -------
       matrix : numpy array (2N × 2N)
           The constructed Hamiltonian matrix containing excitation energies and interactions.
       trans_dip : numpy array (2N × 3)
           The transition dipole moments for each molecule.
       """
 
    #initialize matrix
    matrix = np.zeros((2*len(coordinates),2*len(coordinates)))
    trans_dip = np.zeros((2*len(coordinates),3))
    # loop over each molecule
    for mi1, coord1 in enumerate(coordinates):
        mi1_identifiers = identifiers[mi1]
        # initialization of interaction term
        interaction_term = None
        # loop over pairwise interaction
        for mi2, coord2 in enumerate(coordinates):
            if mi2 == mi1:
                continue
            mi2_identifiers = identifiers[mi2]

            # compute distance between molecules
            distance_vec = coord1-coord2
            distance = np.linalg.norm(distance_vec)
            distance_z = np.abs(distance_vec[2])
            distance_label = f'{distance:.3f}'
            # loop over cutoff ranges 
            for ri, r_max in enumerate(r_cutoffs):
                r_min = 0 if ri == 0 else r_cutoffs[ri-1]
                # check if distance within certain cutoff ranges
                if distance < r_max and distance >= r_min and distance_z <= z_cutoff:
                    # find corresponding interaction terms 
                    if f'{distance:.3f}' in interaction_terms:
                        interaction_term = interaction_terms[distance_label]

                        closest_match = 0
                        closest_match_val = np.dot(interaction_term[0][0]/np.linalg.norm(interaction_term[0][0]), distance_vec/np.linalg.norm(distance_vec))
                        for term_index, [term_distance_vec, term_results] in enumerate(interaction_term):
                            term_match_val = np.dot(term_distance_vec/np.linalg.norm(term_distance_vec), distance_vec/np.linalg.norm(distance_vec))
                            if term_match_val > closest_match_val:
                                closest_match_val = term_match_val
                                closest_match = term_index
                        print(f'({2*mi1:02}x{2*mi2:02}) {distance_label}, {closest_match_val:.3f}, {interaction_term[closest_match][1][coupling].flatten()[1]:.4f}, {interaction_term[closest_match][1][coupling].flatten()[2]:.4f}')

                        # Fill in the diagonal terms (Qs)
                        matrix[2*mi1+0][2*mi1+0] = interaction_term[closest_match][1]['Qx'+mi1_identifiers]
                        matrix[2*mi1+1][2*mi1+1] = interaction_term[closest_match][1]['Qy'+mi1_identifiers]
                        matrix[2*mi2+0][2*mi2+0] = interaction_term[closest_match][1]['Qx'+mi2_identifiers]
                        matrix[2*mi2+1][2*mi2+1] = interaction_term[closest_match][1]['Qy'+mi2_identifiers]

                        # Fill in the off-diagonal terms (Js), upper and lower
                        matrix[2*mi1:2*mi1+2,2*mi2:2*mi2+2] = interaction_term[closest_match][1][coupling]
                       
        if interaction_term is None:
            interaction_term = [val for key, val in interaction_terms.items()][0]
        trans_dip[2*mi1+0] = interaction_term[0][1]['Tx1']
        trans_dip[2*mi1+1] = interaction_term[0][1]['Ty1']
        matrix[2*mi1+0][2*mi1+0] = interaction_term[0][1]['Qx'+mi1_identifiers]
        matrix[2*mi1+1][2*mi1+1] = interaction_term[0][1]['Qy'+mi1_identifiers]
    return matrix, trans_dip


# helper functions for spectra calculation


def voigt_spectral_weight(wavelength_range, eigenvalues, f, gamma=1.0, 
                          gamma_table=[ [820.310766e-9, 45.9188586e-9], 
                                       [853.274140e-9, 48.0870613e-9], 
                                       [889.567148e-9, 38.0147813e-9], 
                                       [914.206437e-9, 42.7828469e-9], 
                                       [945.514185e-9, 49.7859967e-9] ], 
                          sigma=5e-9, c=2.998e8, h=4.135667696e-15, E0=0.0):

    """
    Computes the spectral weight using the Voigt profile, which combines Gaussian and Lorentzian broadening.

    The function:
    - Converts energy eigenvalues into **wavelengths**.
    - Uses a **experimental gamma table** for spectral linewidth broadening.
    - Calculates the **Voigt profile** using the Faddeeva function (`wofz()`).
    - Computes the **final spectral weight** as a sum of weighted Voigt profiles.

    Parameters:
    ----------
    wavelength_range : ndarray
        Array of wavelengths over which to calculate the spectral weight (in meters).
    eigenvalues : ndarray
        Array of energy eigenvalues (in electron volts, eV).
    f : ndarray
        Array of oscillator strengths corresponding to each energy eigenvalue.
    gamma : float, optional
        Unused parameter (default is `1.0`), typically represents the Lorentzian HWHM broadening.
    gamma_table : list, optional
        A list of `[wavelength, gamma]` pairs defining the wavelength-dependent broadening (default contains preset values).
    sigma : float, optional
        Standard deviation of the Gaussian component (default: `5e-9` meters).
    c : float, optional
        Speed of light in meters per second (default: `2.998 × 10^8` m/s).
    h : float, optional
        Planck’s constant in electron-volt seconds (default: `4.135667696 × 10^-15` eV·s).
    E0 : float, optional
        Energy shift for zero-point correction (default: `0.0` eV).

    Returns:
    -------
    spectral_weight : ndarray
        An array of spectral weights computed over the given wavelength range.

    Notes:
    ------
    - The **Voigt profile** is computed using the Faddeeva function (`wofz()`), which describes a convolution of Gaussian and Lorentzian distributions.
    - The **gamma_table** determines the Lorentzian broadening for different spectral regions taken from experiments.
    - This method is commonly used in **spectroscopy** to model **absorption and emission spectra**.

    """
    spectral_weight = np.zeros_like(wavelength_range)

    for i in range(len(eigenvalues)):
        # Convert eigenvalue (energy) to wavelength
        lambda_i = h * c / (eigenvalues[i] - E0)
        
        # find closest gamma value from table corresponding to nearest wavelength match
        gamma_pair = min(gamma_table, key=lambda pair: abs(lambda_i - pair[0]))
        # Calculate the Voigt profile using Faddeeva function
        z = ((wavelength_range - lambda_i) + 1j * gamma_pair[1] * gamma) / (sigma * np.sqrt(2))
        voigt_profile = np.real(wofz(z)) / (sigma * np.sqrt(2 * np.pi))
        
        # Weight profile by oscillator strength
        spectral_weight += f[i] * voigt_profile

    return spectral_weight

def get_spectrum(eigenvalues, oscillator_strengths, wavelength_min=3e-7, wavelength_max=10e-7, gamma=1e-11, E0=0.0):
    """
    Computes the spectral distribution using Voigt profile and identifies spectral peak centers.

    This function:
    - Defines a **wavelength range** between `wavelength_min` and `wavelength_max` for spectral evaluation.
    - Computes the **spectral weight** using **Lorentzian broadening** from energy eigenvalues and oscillator strengths.
    - Converts wavelengths from **meters to nanometers** for better readability.
    - Identifies **local maxima** (peak centers) in the computed spectrum.

    Parameters:
    ----------
    eigenvalues : ndarray
        Array of **energy eigenvalues** (in electron volts, eV).
    oscillator_strengths : ndarray
        Array of **oscillator strengths** for each energy eigenvalue.
    wavelength_min : float, optional
        Minimum wavelength (default: `3e-7` meters or **300 nm**).
    wavelength_max : float, optional
        Maximum wavelength (default: `10e-7` meters or **1000 nm**).
    gamma : float, optional
        Broadening parameter for Lorentzian function (default: `1e-11`).
    E0 : float, optional
        Energy shift for zero-point correction (default: `0.0` eV).

    Returns:
    -------
    spectral_weight : ndarray
        The **computed spectral distribution** over the given wavelength range.
    centers : list
        A list of **indices corresponding to spectral peak centers**.

    Notes:
    ------
    - The spectral weight is computed using **Lorentzian broadening** via `lorentzian_spectral_weight()`.
    - The **peak detection** identifies **local maxima** where intensity increases and then decreases.
    - This function is commonly used in **spectroscopic simulations** to analyze **optical absorption and emission spectra**.

    """
    # wavelength range
    wavelength_range = np.linspace(wavelength_min, wavelength_max, 200000)
    spectral_weight = voigt_spectral_weight(wavelength_range, eigenvalues, oscillator_strengths, gamma=gamma, E0=E0)
       
    # Convert wavelength to nm
    wavelength_range *= 1e9

    # Determine spectral peak centers
    i = 2 # atleast two points before and after
    centers = []
    # peak detection condition atleast 5 points
    while i + 2 < len(spectral_weight):
        if (spectral_weight[i - 2] < spectral_weight[i - 1] and spectral_weight[i - 1] < spectral_weight[i] and
            spectral_weight[i] > spectral_weight[i + 1] and spectral_weight[i + 1] > spectral_weight[i + 2]):
            centers.append(i)
        i += 1

        return wavelength_range, spectral_weight, centers


# helper function for plotting/visualization


def plot_system(ax, mol_coordinates, mol_identifiers, atom_coordinates, 
                atom_identifiers, interaction_terms, show_atoms=False, r_cutoffs=[8, 10], 
                z_cutoff=np.inf, config=None):
    """
    Visualizes a molecular system in 3D space using Matplotlib.
    
    This function plots atoms, bonds, and molecular interactions based on 
    defined distance cutoffs. It supports color-coded representations 
    for atoms and interactions.
    
    Parameters:
    -----------
    ax : matplotlib.axes
        3D plot axis for visualization.
    mol_coordinates : ndarray
        Array of molecular center-of-mass coordinates.
    mol_identifiers : list
        List of molecular identifiers.
    atom_coordinates : ndarray
        Array of atomic coordinates for each molecule.
    atom_identifiers : list
        List of atomic species ('C', 'O', 'N', 'H', etc.).
    interaction_terms : dict
        Dictionary mapping interaction distances to corresponding colors.
    show_atoms : bool, optional
        If True, individual atoms are displayed (default: False).
    r_cutoffs : list, optional
        List of distance cutoffs for molecular interactions (default: [8, 10]).
    z_cutoff : float, optional
        Maximum z-distance for interactions (default: ∞).
    config : dict, optional
        Additional configuration parameters (not used in the current implementation).
    
    Returns:
    --------
    None
        The function modifies the given Matplotlib axis by plotting the molecular system.
    """
    
    
    # atom color and size
    atom_colors = {'H': 'whitesmoke', 'C': 'cyan', 'N': 'mediumblue', 'O': 'red'}
    atom_sizes = {'H': 5, 'C': 8, 'N': 24, 'O': 16}
    atom_filters = ['C','O', 'H','N']
    
    #initialize interaction counts
    interaction_counts = {} # store number of interactions for each distance
    distance_colors = {} # color code distance
    
    # loop over molecule, get atomic coordinates and identifiers
    for mi1, coord1 in enumerate(mol_coordinates):
        coord1_atoms = atom_coordinates[mi1]
        coord1_atom_identifiers = atom_identifiers[mi1]
    
       # plot individual atom
        if show_atoms:
            coord1_atom_colors = [atom_colors[atom] for atom in coord1_atom_identifiers]
            coord1_atom_sizes = [atom_sizes[atom] for atom in coord1_atom_identifiers]
            for c1ai, coord1_atom_identifier in enumerate(coord1_atom_identifiers):
                if coord1_atom_identifier in atom_filters:
                    ax.scatter(coord1_atoms[c1ai,0], coord1_atoms[c1ai,1], coord1_atoms[c1ai,2], color=coord1_atom_colors[c1ai], s=coord1_atom_sizes[c1ai], alpha=0.8)
                # loop through pair of atoms in a molecule and get bond distance
                for c2ai in range(c1ai+1, len(coord1_atom_identifiers)):
                    coord2_atom_identifier = coord1_atom_identifiers[c2ai]
                    if coord2_atom_identifier in atom_filters and coord1_atom_identifier in atom_filters and (coord2_atom_identifier != coord1_atom_identifier or coord2_atom_identifier == 'N'):
                        coord1_atom = coord1_atoms[c1ai]
                        coord2_atom = coord1_atoms[c2ai]
                        distance = np.linalg.norm(coord1_atom-coord2_atom)
                        if distance < 1.6: # different element
                            if coord2_atom_identifier != coord1_atom_identifier:
                                ax.plot(
                                    [coord1_atom[0],coord2_atom[0]],
                                    [coord1_atom[1],coord2_atom[1]],
                                    [coord1_atom[2],coord2_atom[2]],
                                    color='grey', linewidth=1.5, linestyle='-'
                                )
                            else: # same element
                                ax.plot(
                                    [coord1_atom[0],coord2_atom[0]],
                                    [coord1_atom[1],coord2_atom[1]],
                                    [coord1_atom[2],coord2_atom[2]],
                                    color='grey', linewidth=2.0, linestyle='--'
                                )

   
        for ri, r_max in enumerate(r_cutoffs):
            r_min = 0 if ri == 0 else r_cutoffs[ri-1]
            r_min_max_index = f'{r_max:.2f}-{r_min:.2f}'
            if r_min_max_index not in interaction_counts:
                interaction_counts[r_min_max_index] = 0
            for mi2 in range(mi1+1,len(mol_coordinates)):
                coord2 = mol_coordinates[mi2]
                distance = np.linalg.norm(coord1-coord2)
                distance_z = np.abs(coord1[2]-coord2[2])
                if distance < r_max and distance >= r_min and distance_z <= z_cutoff:# and distance < 14.015 and distance > 14.012:
                    interaction_counts[r_min_max_index] += 2
                    distance_label = f'{distance:.3f}'
                    if distance_label in interaction_terms and len(mol_coordinates) <= 120:
                        distance_color=interaction_terms[distance_label][0][1]['color']
    
                        if distance_label in distance_colors:
                            #continue
                            ax.plot(
                                    [coord1[0],coord2[0]],
                                    [coord1[1],coord2[1]],
                                    [coord1[2],coord2[2]],
                                    linewidth=3.0, alpha=distance_color, linestyle='-', color=distance_color)
                        else:
                            #continue
                            line, = ax.plot(
                                    [coord1[0],coord2[0]],
                                    [coord1[1],coord2[1]],
                                    [coord1[2],coord2[2]],
                                    label=distance_label+r'$\AA$',
                                    linewidth=3.0, alpha=distance_color, linestyle='-', color=distance_color)
                            distance_colors[distance_label] = distance_color
    


# command line execution block

if __name__ == "__main__":
    # Set up argument parser
    parser = argparse.ArgumentParser(description="Load JSON files and perform calculations for different groups.")
    parser.add_argument("molecule", help="Name of the molecule.")
    parser.add_argument('functional', type=str, help='Name of the functional folder within molecule folder within Qchem_files.')
    parser.add_argument('systems', type=str, help='System dimensions specified as rows,cols,layers;rows,cols,layers')
    parser.add_argument("--zcut", type=float, default=np.inf, help="Z distance above and below which to stop search for neighbors.")
    parser.add_argument("--rcut", type=str, default='8,10', help="R cutoffs for each system specified as 8,10;8,10,15")
    parser.add_argument("--replicas", type=int, default=1, help="Number of unit cells to draw in all dimensions.")
    parser.add_argument("--zigzag", type=str, default="null", help="Select a zigzag configuration for each system, Use system X,1,1 to specify number of molecules. 0 disables, 1 is first type and 2 is second type.")
    parser.add_argument("--coupling", type=str, default='J_coul', help="Coupling: J_coul, J_dipole or J_both e.g. J_coul;J_dipole")
    parser.add_argument("--gamma", type=float, help="Broadening parameter.")
    parser.add_argument("--atoms", action='store_true', help="Show atoms in plot.")
    parser.add_argument("--digitized", type=str, default="", help="Specify a file with digitized data from experimental results.")
    parser.add_argument("--eshift", type=float, default=0.0, help="Specify a shift in energy when calculating the lorentzian spectral weight.")
    parser.add_argument("--save", action='store_true', help="Save the plots rather than showing them.")
    
    # Parse arguments
    args = parser.parse_args()
    
    # user-provided command line parses
    functionals = args.functional.split(';')
    systems = args.systems.split(';')
    rcuts = args.rcut.split(';')
    couplings = args.coupling.split(';')
    
    # splits multi-value arguments (functional, systems, rcut, and coupling) into lists, allowing multiple configurations to be processed
    config_count = len(functionals) * len(systems) * len(rcuts) * len(couplings) # total number of configurations to iterate over
    
    # prepare the spectral plots
    fig, axes = plt.subplots(ncols=1,nrows=1,figsize=(12,10))
    
    # experimental data processing; check if user provided digitized experimental data
    spectral_max = -1
    if len(args.digitized) > 0:
        file_path = args.digitized

        # Read experimental data
        wavelengths = []
        intensities = []

        # Process the file
        with open(file_path, 'r') as file:
            for line in file:
                # Skip empty lines
                if line.strip():
                    # Replace commas with tabs and split the line
                    values = line.replace(",", "\t").strip().split("\t")
                   
                    # Append values to the respective lists
                    try:
                        wavelengths.append(float(values[0]))
                        intensities.append(float(values[1]))
                    except ValueError:
                        print(f"Skipping line due to conversion error: {line}")

        # Calculate half intensities
        wavelengths = np.array(wavelengths)
        intensities = np.array(intensities)
        half_intensities = np.array([y / 2 for y in intensities])

        # find maximum intensity above wavelength 897nm (hard coded from experimental data)
        spectral_max = np.max(intensities[np.where(wavelengths>897)])

        # plot experimental data
        axes.plot(wavelengths, intensities, marker='o', linestyle='-', color='b', label="Expt.", zorder=0)
        axes.set_xlim(700,1100)
        axes.legend(fontsize=24, loc='best', frameon=False)
        
        
        # iterating through different functionals, JSON files
        # Split the functional string into multiple functionals
        configuration_index = 0

        system_matrix = []
        for functional in functionals:
            # Construct the base folder path for the molecule
            base_folder = os.path.join('..', 'systems', 'Qchem_files', args.molecule, functional)

            # Find all JSON files in the specified folder
            json_files = find_json_files(base_folder)
            #print(json_files)
           
            # Collect all molecule data here with all possible cutoffs in case we need to use a layered system later, first molecular pair (dimer) = [0,1]
            molecule_data, unique_molecules = extract_molecule_data([0,1], json_files, r_cutoffs=[8,10,15,17,28,30,32,36,41,np.inf], z_cutoff=np.inf)
            interaction_terms = extract_interaction_terms(json_files)
            
            
            # iterates over system configurations, constructs molecular structures, builds matrices, and diagonalizes them
            for system_index, system in enumerate(systems):
                # extract dimensions
                rows, cols, layers = [int(dim) for dim in system.split(',')]

                # extract zigzag as well
                for rcut_index, rcut in enumerate(rcuts):
                    # extract r cutoffs
                    r_cutoffs = [float(r) for r in rcut.split(',')]
                    label = f'{r_cutoffs}'

                    for coupling in couplings:
                        zigzag = 0
                        if args.zigzag != 'null':
                            zigzags = args.zigzag.split(';')
                            if len(zigzags) > configuration_index:
                                zigzag = int(zigzags[configuration_index])
                        configuration_index += 1 # tracks configurations

                        #label = f'{functional}: {rows}x{cols}x{layers}, {r_cutoffs}, {coupling}'

                        # build molecular systems
                        mol_coordinates, mol_identifiers, atm_coordinates, atm_identifiers, mol_layers = build_system(cols, rows, molecule_data, layers=layers, zigzag=zigzag)
                        
                        # build TB-Hamiltonian
                        matrix, trans_dip = build_matrix(mol_coordinates, mol_identifiers, interaction_terms, r_cutoffs=r_cutoffs, z_cutoff=args.zcut, coupling=coupling)
                        system_matrix.append(matrix)

                        # build the plot labels
                        if (rows > 1 and cols == 1 and layers == 1 and zigzag == 0):
                            # This is the armchair label
                            dlabel = '1D-BACA'
                            dcolor='darkgoldenrod'
                            #dmarker= 's'
                            dlinestyle='dotted'
                        elif (rows == 2 and cols > 1 and layers == 1 and zigzag == 0):
                            # This is the first zigzag label
                            dlabel = '1D-BC'
                            dcolor='black'
                            #dmarker='*'
                            dlinestyle = 'dashdot'
                        elif (rows > 1 and cols == 1 and layers == 1 and zigzag == 1):
                            # This is the second zigzag label
                            dlabel = '1D-AB'
                            dcolor='red'
                            #dmarker='v'
                            dlinestyle='solid' #dashdot
                        elif (rows > 1 and cols == 1 and layers == 1 and zigzag == 2):
                            # This is the second zigzag label
                            dlabel = '1D-AC'
                            dcolor='violet'
                            #dmarker='d'
                            dlinestyle='dashed'
                        elif layers == 1:
                            dlabel = '2D'
                            dcolor='orange'
                        else:
                            dlabel = '3D'
                            dcolor='g'

                        # print matrices for debugging, attempt smaller systems
                        molecules = rows*cols*layers
                        if molecules < 20:
                            for index, row in enumerate(matrix.T):
                                print_it = f'{index:03}:'
                                for col in row:
                                    val = f'{col:.3f}'
                                    print_it += f' {val:>8}'
                                print(print_it)

                        # diagonalize TB ham for eigenvalues and eigenvectors
                        eigenvalues, eigenvectors = np.linalg.eigh(matrix)
                        # print eigenvalues and eigenvectors for debugging
                        if molecules < 20:
                            for i, ev in enumerate(eigenvectors.T):
                                print_it = f'{i:02} ({eigenvalues[i]:.3f}):'
                                for j in list(reversed(np.argsort(np.abs(ev)))):#find indices for largest component
                                    val = ev[j]
                                    print_it += f' ({j:02},{val:.3f})' if val < 0 else f' ({j:02}, {val:.3f})'

                                for val in ev:
                                    print_it += f' {val:.3f}' if val < 0 else f' {val:.4f}'
                                print(print_it)
                        # calculate oscillator strength        
                        f1 = (2.0 / 3.0) * np.einsum('k,ik,jk,ix,jx->k', eigenvalues / 27.21, eigenvectors.T, eigenvectors.T, trans_dip, trans_dip)  
                        
                        # loop over spectral weight, compute spectral weight with f1, PR add-on IPR f2
                        for i, f in enumerate([f1]):
                            wavelength_range, spectral_weight, centers = get_spectrum(
                                    eigenvalues,
                                    f,
                                    wavelength_min=7e-7,
                                    wavelength_max=11e-7,
                                    gamma=args.gamma,
                                    E0=args.eshift
                            )
                            # use area to normalize
                            area = simpson(spectral_weight, x=wavelength_range)
                            spectral_weight /= area
                            # 
                            if spectral_max == -1:
                                spectral_max = max(spectral_weight)
                            factor = spectral_max / max(spectral_weight)

                            if config_count == 1:
                                line, = axes.plot(wavelength_range, factor * spectral_weight, label=label)
                                if len(centers) < 20:
                                    for center in centers:
                                        wavelength = wavelength_range[center]
                                        xvals = [wavelength, wavelength]
                                        yvals = [0, factor * spectral_weight[center]]
                                        axes.plot(xvals, yvals, linestyle='--', linewidth=4, label=f'{wavelength:.1f}nm')
                                    axes.legend(fontsize=24, frameon=False)
                            else:
                                line, = axes.plot(wavelength_range, factor * spectral_weight, linestyle=dlinestyle, color=dcolor, linewidth=4, label=f'{dlabel}') #, label=label+f' ({area/1e9:.2f})'
                                axes.legend(fontsize=24, loc='best', bbox_to_anchor=(0.75, 0.85), borderaxespad=0.5, frameon=False)
                            axes.set_ylabel(f'Absorbance', fontsize=30)
                            axes.text(705, 1.1*spectral_max, r'PBE0, 1NN-10$\AA$, $\Delta$E$_{shift}$ = 0.43 eV', fontsize=30) # PR later for generalization
                            axes.text(-0.1, 1, r'(d)', fontsize=30 , transform=axes.transAxes, clip_on=False)      # PR later for generalization
                            axes.tick_params(axis="x", labelsize=30)
                            axes.tick_params(axis="y", labelsize=30)
                            axes.set_ylim(0,1.2*spectral_max)
                            axes.set_xlabel('Wavelength (nm)', fontsize=30)

    print("Difference matrix")
    for mat_index in range(1, len(system_matrix)):
        mat_diff = system_matrix[mat_index] - system_matrix[mat_index-1]
        for index, row in enumerate(mat_diff.T):
            print_it = f'{index:03}:'
            for col in row:
                val = f'{col:.3f}'
                print_it += f' {val:>8}'
            print(print_it)
    
    print("Symmetric matrix")
    for mat_index in range(0, len(system_matrix)):
        mat_symm = system_matrix[mat_index]
        for i in range(len(mat_symm[0])):
            for j in range(i+1, len(mat_symm[0])): 
                mat_symm[i][j], mat_symm[j][i] = mat_symm[i][j] - mat_symm[j][i], mat_symm[j][i] - mat_symm[i][j]
        for index, row in enumerate(mat_symm.T):
            print_it = f'{index:03}:'
            for col in row:
                val = f'{col:.3f}'
                print_it += f' {val:>8}'
            print(print_it)

    if len(args.digitized) > 0:
        axes.legend(fontsize=24, loc='best', borderaxespad=0.5, frameon=False) #
        axes.legend(fontsize=24, loc='best', frameon=False)
    if args.save:
        fig.savefig(functional + '_' + label.replace(',','-').replace(' ','') + f'_{args.rcut}_{args.eshift}_spectrum_2D.pdf')
    else:
        fig.savefig('PBE0-1d-coul-NN-10.pdf', bbox_inches='tight') # PR later
        plt.show()




    
     
